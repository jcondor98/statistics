var y=class n extends p{static name="caesar";constructor(t={key:0}){super(t)}static rot(t){return new n({key:t})}encrypt(t){return[...t].map(r=>{let e=r.charCodeAt(0);return e>=i&&e<=l?e=i+(e-i+this.key)%26:e>=c&&e<=d&&(e=c+(e-c+this.key)%26),String.fromCharCode(e)}).join("")}decrypt(t){return[...t].map(r=>{let e=r.charCodeAt(0);return e>=i&&e<=l?e=i+(e-i+26-this.key)%26:e>=c&&e<=d&&(e=c+(e-c+26-this.key)%26),String.fromCharCode(e)}).join("")}static*all(){for(let t of a(0,26))yield new n({key:t})}toString(){return`CaesarCipher(${this.key})`}};var h=[29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127];function m(n,t){if(t===0)return[n,1,0];let[r,e,o]=m(t,n%t);return[r,o,e-Math.floor(n/t)*o]}function k(n,t){let[r,e]=m(n,t);if(r!==1)throw new Error("No modular inverse");return(e%t+t)%t}function w(n,t,r){let e=1;for(n%=r;t>0;)t%2===1&&(e=e*n%r),n=n*n%r,t=Math.floor(t/2);return e}var x=class n extends p{static name="letterwise-rsa";constructor(t){super(t)}static fromPrimes(t,r){if(t===r)throw new Error("p and q must differ");return new n({p:t,q:r,key:this.generateKeys(t,r)})}static random(){let[t,r]=this.pickRandomPrimes();return this.fromPrimes(t,r)}static pickRandomPrimes(){function t(){return h[Math.floor(Math.random()*h.length)]}let r=t(),e=t();for(;r===e;)e=t();return[r,e]}static generateKeys(t,r){let e=t*r,o=(t-1)*(r-1),s;for(s=2;s<o&&m(s,o)[0]!==1;s++);let u=k(s,o);return{public:{e:s,n:e},private:{d:u,n:e}}}encrypt(t){let{e:r,n:e}=this.key.public,o=[...t].map(s=>s.charCodeAt(0)).map(s=>w(s,r,e));return JSON.stringify(o)}static adaptCiphertext(t){return typeof t=="string"?JSON.parse(t):typeof t=="number"?[t]:t}decrypt(t){let{d:r,n:e}=this.key.private;return this.constructor.adaptCiphertext(t).map(o=>w(o,r,e)).map(o=>String.fromCharCode(o)).join("")}static*all(){for(let t of a(0,h.length))for(let r of a(t+1,h.length))yield n.fromPrimes(h[t],h[r])}toString(){return`LetterwiseRSA(p=${this.context.p}, q=${this.context.q})`}};var i=97,l=122,c=65,d=90,A=26;function*a(n,t,r=1){for(let e=n;e<t;e+=r)yield e}function O(n){let t=n.charCodeAt(0);return t>=i&&t<=l||t>=c&&t<=d}var g=class n extends Map{defaultValue=0;constructor(...t){super(...t)}get(t){return super.get(t)||this.defaultValue}setDefaultValue(t){defaultValue=t}static empty(){return new n}static of(t){return n.raw([...t.toLowerCase()].filter(r=>O(r)))}static raw(t){let r=new n;for(let e of t)r.set(e,r.get(e)+1);for(let[e,o]of r.entries())r.set(e,o/t.length);return r}distanceFrom(t){let r=0;for(let[e,o]of this)r+=Math.abs(o-t.get(e));return r}remap(t){let r=new n;for(let[e,o]of this)r.set(t(e),o);return r}alphabetic(){let t=new n;for(let r of a(0,26)){let e=String.fromCharCode(i+r),o=String.fromCharCode(c+r);t.set(e,this.get(e)+this.get(o))}return t}detectLanguage(t){let r={language:null,distance:A};for(let e in t){let o=this.distanceFrom(t[e]);o<r.distance&&(r={language:e,distance:o})}return r}static manyByLanguage(t){let r={};for(let e in t)r[e]=new n(Object.entries(t[e]));return r}},p=class{constructor(t={}){this.context=t}get key(){return this.context.key}static name="generic";encrypt(t,r){throw new Error("encrypt() is not implemented for this Cipher")}decrypt(t,r){throw new Error("decrypt() is not implemented for this Cipher")}static adaptCiphertext(t){return t}static*all(){throw new Error("all() is not implemented for this Cipher")}toString(){return"Cipher"}},E=class{constructor({cipher:t,frequencies:r,language:e}){this.cipher=t,this.frequencies=r,this.language=e}crack(t){let r=this.cipher.constructor?.all||this.cipher.all;t=(this.cipher.constructor?.adaptCiphertext||this.cipher.adaptCiphertext)(t);let o=g.raw(t),s={distance:A};for(let u of r()){let P=o.remap(f=>u.decrypt(f)).alphabetic();for(let f in this.frequencies){let C=P.distanceFrom(this.frequencies[f]);C<s.distance&&(s={language:f,distance:C,cipher:u})}}return s}};export{y as CaesarCipher,p as Cipher,E as Cracker,A as FREQ_MAX_GUESS_DISTANCE,g as FrequencyAnalysis,i as LOWER_A_CODE,l as LOWER_Z_CODE,x as LetterwiseRSA,c as UPPER_A_CODE,d as UPPER_Z_CODE,m as egcd,O as isAlphabetic,k as modInv,w as modPow,a as range};
