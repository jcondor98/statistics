var i=97,m=122,c=65,C=90,l=26;function*a(o,t,e=1){for(let r=o;r<t;r+=e)yield r}function y(o){let t=o.charCodeAt(0);return t>=97&&t<=122||t>=65&&t<=90}var d=class o extends Map{defaultValue=0;constructor(...t){super(...t)}get(t){return super.get(t)||this.defaultValue}setDefaultValue(t){defaultValue=t}static empty(){return new o}static of(t){return o.raw([...t.toLowerCase()].filter(e=>y(e)))}static raw(t){let e=new o;for(let r of t)e.set(r,e.get(r)+1);for(let[r,n]of e.entries())e.set(r,n/t.length);return e}distanceFrom(t){let e=0;for(let[r,n]of this)e+=Math.abs(n-t.get(r));return e}remap(t){let e=new o;for(let[r,n]of this)e.set(t(r),n);return e}alphabetic(){let t=new o;for(let e of a(0,26)){let r=String.fromCharCode(97+e),n=String.fromCharCode(65+e);t.set(r,this.get(r)+this.get(n))}return t}detectLanguage(t){let e={language:null,distance:26};for(let r in t){let n=this.distanceFrom(t[r]);n<e.distance&&(e={language:r,distance:n})}return e}static manyByLanguage(t){let e={};for(let r in t)e[r]=new o(Object.entries(t[r]));return e}};var p=class{constructor(t={}){this.context=t}get key(){return this.context.key}static name="generic";encrypt(t,e){throw new Error("encrypt() is not implemented for this Cipher")}decrypt(t,e){throw new Error("decrypt() is not implemented for this Cipher")}static adaptCiphertext(t){return t}static*all(){throw new Error("all() is not implemented for this Cipher")}toString(){return"Cipher"}},_=class{constructor({cipher:t,frequencies:e,language:r}){this.cipher=t,this.frequencies=e,this.language=r}crack(t){let e=this.cipher.constructor?.all||this.cipher.all;t=(this.cipher.constructor?.adaptCiphertext||this.cipher.adaptCiphertext)(t);let n=d.raw(t),s={distance:26};for(let h of e()){let O=n.remap(u=>h.decrypt(u)).alphabetic();for(let u in this.frequencies){let E=O.distanceFrom(this.frequencies[u]);E<s.distance&&(s={language:u,distance:E,cipher:h})}}return s}};var x=class o extends p{static name="caesar";constructor(t={key:0}){super(t)}static rot(t){return new o({key:t})}encrypt(t){return[...t].map(e=>{let r=e.charCodeAt(0);return r>=97&&r<=122?r=97+(r-97+this.key)%26:r>=65&&r<=90&&(r=65+(r-65+this.key)%26),String.fromCharCode(r)}).join("")}decrypt(t){return[...t].map(e=>{let r=e.charCodeAt(0);return r>=97&&r<=122?r=97+(r-97+26-this.key)%26:r>=65&&r<=90&&(r=65+(r-65+26-this.key)%26),String.fromCharCode(r)}).join("")}static*all(){for(let t of a(0,26))yield new o({key:t})}toString(){return`CaesarCipher(${this.key})`}};var f=[29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127];function g(o,t){if(t===0)return[o,1,0];let[e,r,n]=g(t,o%t);return[e,n,r-Math.floor(o/t)*n]}function P(o,t){let[e,r]=g(o,t);if(e!==1)throw new Error("No modular inverse");return(r%t+t)%t}function w(o,t,e){let r=1;for(o%=e;t>0;)t%2===1&&(r=r*o%e),o=o*o%e,t=Math.floor(t/2);return r}var A=class o extends p{static name="letterwise-rsa";constructor(t){super(t)}static fromPrimes(t,e){if(t===e)throw new Error("p and q must differ");return new o({p:t,q:e,key:this.generateKeys(t,e)})}static random(){let[t,e]=this.pickRandomPrimes();return this.fromPrimes(t,e)}static pickRandomPrimes(){function t(){return f[Math.floor(Math.random()*f.length)]}let e=t(),r=t();for(;e===r;)r=t();return[e,r]}static generateKeys(t,e){let r=t*e,n=(t-1)*(e-1),s;for(s=2;s<n&&g(s,n)[0]!==1;s++);let h=P(s,n);return{public:{e:s,n:r},private:{d:h,n:r}}}encrypt(t){let{e,n:r}=this.key.public,n=[...t].map(s=>s.charCodeAt(0)).map(s=>w(s,e,r));return JSON.stringify(n)}static adaptCiphertext(t){return typeof t=="string"?JSON.parse(t):typeof t=="number"?[t]:t}decrypt(t){let{d:e,n:r}=this.key.private;return this.constructor.adaptCiphertext(t).map(n=>w(n,e,r)).map(n=>String.fromCharCode(n)).join("")}static*all(){for(let t of a(0,f.length))for(let e of a(t+1,f.length))yield o.fromPrimes(f[t],f[e])}toString(){return`LetterwiseRSA(p=${this.context.p}, q=${this.context.q})`}};export{x as CaesarCipher,p as Cipher,_ as Cracker,l as FREQ_MAX_GUESS_DISTANCE,d as FrequencyAnalysis,i as LOWER_A_CODE,m as LOWER_Z_CODE,A as LetterwiseRSA,c as UPPER_A_CODE,C as UPPER_Z_CODE,g as egcd,y as isAlphabetic,P as modInv,w as modPow,a as range};
